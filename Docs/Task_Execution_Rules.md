# 📋 Pathcraft AI — 태스크 실행 규칙 (Task Execution Rules)

## 🎯 목적
이 문서는 Pathcraft AI 프로젝트의 태스크를 체계적으로 진행하기 위한 **필수 규칙**을 정의합니다.

---

## ✅ 최근 완료 작업 (2025-11-02)

### CR1 — 코드 리뷰 및 성능 최적화 ✅
**완료:** Phase 1 이후 전체 프로젝트 검토 및 최적화

**주요 성과:**
- ✅ 불필요한 코드 제거: Class1.cs 4개 파일 삭제
- ✅ 경로 캐싱 시스템 구현: PathCache.cs 추가
- ✅ 성능 최적화: 5가지 주요 개선 사항 적용
- ✅ 빌드 검증: Release/Debug 모두 0 경고, 0 오류

**성능 개선 결과:**
| 항목 | 개선율 |
|------|--------|
| 경로 탐색 캐싱 | 92% ↑ |
| OverlayWindow 최적화 | CPU 사용률 ↓ |
| ReasoningFiller 복잡도 | O(n*m) → O(n) |
| BuildNormalizer 조기 종료 | 30~50% ↑ |
| Python 설치 크기 | -5MB+ |

**현재 상태:** P5 완료 후 최적화 완료 → P6 시작 준비 완료

---

## ⚠️ 핵심 규칙 (반드시 준수)

### 0. 테스트 필수 원칙 (가장 중요!)
- 🔴 **코드 작성/수정 완료 후 반드시 테스트 실행**
- 🔴 **테스트가 100% 통과한 경우에만 개발자에게 보고**
- 🔴 **테스트 실패 시 개발자에게 보고 금지 → 먼저 수정**
- ✅ 빌드 에러 0개 확인
- ✅ 런타임 에러 0개 확인
- ✅ 모든 테스트 케이스 통과
- ✅ 기존 기능 회귀 테스트 통과
- ⚠️ **"완료했습니다" 라는 말은 "테스트 100% 통과" 를 의미함**

### 1. 순차적 진행 원칙
- ✅ **반드시 P6부터 순서대로** 진행 (P1~P5는 완료됨)
- ❌ 태스크 건너뛰기 금지
- ❌ 여러 태스크 동시 작업 금지
- ✅ 의존성이 있는 태스크는 선행 태스크 완료 후 시작

### 2. 확인 절차 (가장 중요!)
각 태스크는 다음 3단계 확인을 **반드시** 거쳐야 합니다:

#### Step 1: 작업 완료
- 태스크 리스트의 모든 체크박스 완료
- 코드 작성 및 테스트 완료

#### Step 2: 개발자 확인 요청
```
"P[번호] - [태스크명] 완료했습니다.
다음 내용을 확인해주세요:
- [완료한 주요 작업 1]
- [완료한 주요 작업 2]
- [완료한 주요 작업 3]

테스트 결과:
- [테스트 1]: 성공/실패
- [테스트 2]: 성공/실패

확인 후 다음 태스크로 진행하겠습니다."
```

#### Step 3: 체크리스트 업데이트
- 개발자 확인 완료 후 해당 태스크의 **"개발자 확인 완료"** 체크
- TaskList_Checklist.md 파일 업데이트
- 다음 태스크로 진행

### 3. 코드 작성 원칙
- ✅ **리팩토링 금지** (기존 정책 유지)
- ✅ 누적 확장 방식으로 작성
- ⚠️ **기존 작동하는 기능은 절대 건드리지 않음** (매우 중요!)
- ✅ 새 기능은 기존 코드에 추가만 하기
- ❌ 기존 기능을 지우고 다시 만드는 것 금지
- ✅ 예외: 완전히 사용하지 않거나 꼬인 기능만 삭제 후 재생성
- ✅ 주석 충분히 작성
- ✅ 변수명/함수명 명확하게
- ✅ 디버그 로그 적극 활용

### 4. 테스트 원칙
- ✅ **매 태스크 완료 시 반드시 테스트**
- ✅ 태스크 리스트의 모든 테스트 항목 실행
- ✅ **에러 없음 확인 후 다음 태스크 진행**
- ✅ 실패한 테스트는 반드시 수정
- ✅ 테스트 결과를 개발자에게 보고
- ⚠️ **기존 기능이 정상 작동하는지 회귀 테스트**

### 테스트 방법
```csharp
// 간단한 테스트 로직은 Program.cs 또는 디버그 메뉴에 추가
public void TestP6_StashMockData()
{
    var stashData = LoadStashMock();
    Debug.WriteLine($"[TEST P6] Loaded {stashData.Items.Count} items");
    
    foreach (var item in stashData.Items)
    {
        Debug.WriteLine($"  - {item.Name} ({item.Type}): {item.EstimatedPrice.Chaos}c");
    }
    
    // 기존 기능 회귀 테스트
    TestP5_HotkeyStillWorks();
}

public void TestP5_HotkeyStillWorks()
{
    // P1~P5 기능이 여전히 작동하는지 확인
    Debug.WriteLine("[TEST P5] Hotkey test...");
    // Ctrl + F8 토글 테스트
}
```

### 5. 문제 발생 시
- ❌ 30분 이상 막히면 **즉시** 개발자에게 질문
- ✅ 문제 상황을 구체적으로 설명
- ✅ 시도한 해결 방법 공유
- ✅ 에러 메시지 전체 복사 (스택 트레이스 포함)

---

## 📝 표준 작업 흐름

### 태스크 시작 전
```
1. TaskList_Checklist.md 확인
2. 현재 태스크의 의존성 확인
3. 선행 태스크가 완료되었는지 확인
4. 필요한 파일/폴더 경로 확인
5. PRD에서 관련 명세 재확인
```

### 태스크 진행 중
```
1. 주요 작업 체크박스 하나씩 완료
2. 각 작업 완료 후 간단한 테스트
3. 막히는 부분 있으면 즉시 질문
4. 중간 진행 상황 주기적 보고 (선택)
5. **모든 작업 완료 후 테스트 실행**
```

### 태스크 완료 시
```
1. 모든 작업 체크박스 확인
2. 🔴 **테스트 실행 (필수 1단계)**
3. 🔴 **빌드 에러 0개 확인**
4. 🔴 **런타임 에러 0개 확인**
5. 🔴 **모든 테스트 케이스 100% 통과 확인**
6. 🔴 **기존 기능 회귀 테스트 통과 확인**
7. ⚠️ **테스트 실패 시 → 수정 → 1번부터 다시**
8. ✅ 모든 테스트 통과 후에만 테스트 결과 정리
9. ✅ 개발자에게 확인 요청 (테스트 100% 통과 시에만)
10. 확인 완료 후 체크리스트 업데이트
11. 다음 태스크로 이동
```

---

## 🔍 체크리스트 업데이트 방법

### 방법 1: str_replace 도구 사용
```python
# 예시: P6 완료 시
str_replace(
    path="/mnt/user-data/outputs/TaskList_Checklist.md",
    old_str="- [ ] **개발자 확인 완료**",
    new_str="- [x] **개발자 확인 완료**",
    description="P6 개발자 확인 완료 체크"
)
```

### 방법 2: 전체 섹션 업데이트
해당 태스크의 모든 체크박스를 한 번에 업데이트

---

## 📊 진행도 추적

### 매 태스크 완료 시
- [ ] 작업 완료
- [ ] 테스트 완료
- [ ] 개발자 확인 완료
- [ ] 체크리스트 업데이트
- [ ] 다음 태스크 시작

### Phase 완료 시
- [ ] Phase 내 모든 태스크 완료
- [ ] Phase 통합 테스트
- [ ] Phase 완료 체크박스 업데이트

---

## ⚡ 효율적인 작업을 위한 팁

### 1. 작업 전 준비
- PRD 해당 섹션 읽기
- 관련 스크립트 구조 파악
- 필요한 리소스 준비

### 2. 코딩 중
- 자주 저장 (Ctrl+S)
- 단위별로 테스트
- Git 커밋 습관화 (선택)

### 3. 테스트 시
- 엣지 케이스 고려
- 에러 로그 확인
- 예상치 못한 동작 체크

### 4. 보고 시
- 간결하게 핵심만
- 스크린샷 활용 (선택)
- 문제 발생 시 로그 첨부

---

## 🚫 하지 말아야 할 것

1. ❌ 태스크 순서 무시
2. ❌ 개발자 확인 없이 다음 태스크 진행
3. ❌ 테스트 생략
4. 🔴 **테스트 실패 상태에서 개발자에게 보고** (절대 금지!)
5. ❌ 체크리스트 업데이트 누락
6. ❌ 리팩토링 (기존 코드 수정 최소화)
7. ❌ **기존 작동하는 기능을 건드리기** (매우 중요!)
8. ❌ 임의로 기능 추가
9. ❌ PRD 명세와 다르게 구현
10. ❌ 문제 발생 시 혼자 오래 고민
11. 🔴 **빌드 에러가 있는 상태에서 "완료" 보고** (절대 금지!)

### ⚠️ 기존 기능 보존 규칙 (매우 중요!)

**상황별 대응:**

#### ✅ 올바른 방식: 기능 추가 (확장)
```csharp
// 기존 코드 (P3에서 작성)
public class OverlayWindow {
    public void UpdateBuildData(BuildSnapshot build) {
        // 기존 로직 (절대 수정하지 않음!)
        BuildNameText.Text = build.Name;
    }
}

// 새 기능 추가 (P8에서 작성)
public class OverlayWindow {
    public void UpdateBuildData(BuildSnapshot build) {
        // 기존 로직 유지
        BuildNameText.Text = build.Name;
    }
    
    // 새로운 메서드 추가
    public void UpdateStashData(StashData stash) {
        // 새 로직
        StashItemCountText.Text = $"Items: {stash.Items.Count}";
    }
}
```

#### ❌ 잘못된 방식: 기존 기능 수정
```csharp
// 절대 이렇게 하지 말 것!
public class OverlayWindow {
    public void UpdateBuildData(BuildSnapshot build) {
        // 기존 로직을 지우고 새로 작성 ← 금지!
        BuildNameText.Text = $"{build.Name} - Level {build.Level}";
    }
}
```

#### ⚠️ 예외: 완전히 망가진 경우만 재작성
```
상황: P4에서 만든 기능이 완전히 꼬여서 사용 불가능
판단: 
- 이 기능이 현재 사용 중인가? → NO
- 다른 기능이 의존하는가? → NO
- 완전히 새로 만드는 게 나은가? → YES

→ 개발자에게 확인 후 삭제 및 재작성 가능
```

**왜 이렇게 해야 하는가?**
- 이유 1: 기존 기능 수정 시 예상치 못한 버그 발생
- 이유 2: 새 기능 만들다가 기존 기능까지 망가짐
- 이유 3: 디버깅 시간 2배 이상 소요
- 결론: **기존 작동 코드는 절대 건드리지 않기!**

---

## ✅ 반드시 해야 할 것

1. ✅ 순차적 진행
2. 🔴 **코드 작성/수정 후 반드시 테스트** (최우선!)
3. 🔴 **테스트 100% 통과 후에만 개발자 확인** (최우선!)
4. ✅ 모든 테스트 수행
5. ✅ 체크리스트 업데이트
6. ✅ 주석 작성
7. ✅ 명확한 변수명
8. ✅ PRD 명세 준수
9. ✅ 문제 시 즉시 질문
10. ✅ 빌드 에러 0개 확인
11. ✅ 런타임 에러 0개 확인

---

## 📋 태스크 완료 보고 템플릿

### 표준 보고 양식
```
====================================
태스크 완료 보고
====================================

태스크: P[번호] - [태스크명]
예상 시간: [N]시간
실제 소요: [N]시간

✅ 완료한 작업:
- [작업 1]
- [작업 2]
- [작업 3]

🧪 테스트 결과: (⚠️ 필수 - 모두 성공해야만 보고 가능)
- 빌드 에러: ✅ 0개 (필수)
- 런타임 에러: ✅ 0개 (필수)
- [테스트 1]: ✅ 성공 (실패 시 보고 금지)
- [테스트 2]: ✅ 성공 (실패 시 보고 금지)
- [테스트 3]: ✅ 성공 (실패 시 보고 금지)

🔄 기존 기능 회귀 테스트:
- P1~P5 기능: ✅ 정상 작동 (필수)
- 기존 기능 영향: ✅ 없음

📁 생성/수정 파일:
- [파일 경로 1]
- [파일 경로 2]

❓ 특이사항/질문:
- [특이사항 또는 질문 사항]

⚠️ 모든 테스트 100% 통과 확인 완료
확인 후 다음 태스크 P[번호+1]로 진행하겠습니다.
====================================
```

---

## 🎯 Phase별 특별 규칙

### Phase 2 (P6~P9): 스태시 분석 기초
- 목업 데이터는 실제 POE 아이템 구조와 유사하게
- JSON 구조는 GGG Stash API 형식 참고
- 테스트 데이터는 다양한 타입 포함 (무기/방어구/악세서리)

### Phase 3 (P10~P12): poe.ninja 연동
- API 호출 실패 시 캐시된 데이터 사용
- Rate Limiting 주의 (너무 자주 호출 금지)
- 응답 데이터는 1시간 캐싱

### Phase 4 (P13~P15): GGG OAuth
- OAuth 토큰은 반드시 암호화 저장
- Redirect URI는 로컬 서버 (http://localhost:8080)
- 토큰 만료 시 자동 갱신 로직 필수

### Phase 5 (P16~P19): AI 통합
- API 키는 사용자가 직접 입력 (하드코딩 금지)
- 프롬프트는 간결하게 (토큰 비용 고려)
- AI 응답 시간 10초 이상 시 타임아웃 처리

### Phase 6 (P20~P22): UI/UX
- WPF XAML 자동 생성 시 배치 주의
- 반응형 레이아웃 필수 (해상도 대응)
- 테마는 POE 게임 스타일 유지

### Phase 7 (P23~P26): 배포 준비
- 에러는 사용자 친화적 메시지로 변환
- 로그는 민감 정보 제외 (API 키 등)
- 문서는 초보자도 이해 가능하게

---

## 🔄 반복 주기

매 태스크마다:
```
1. 시작 → 2. 작업 → 3. 테스트 → 4. 보고 → 5. 확인 → 6. 업데이트 → 1. 다음 시작
```

---

## 📞 개발자 확인이 필요한 경우

### 반드시 확인 받아야 하는 경우
1. ✅ 태스크 완료 시 (필수)
2. ✅ 예상 시간 2배 이상 초과 시
3. ✅ PRD와 다르게 구현해야 할 경우
4. ✅ 30분 이상 막힌 경우
5. ✅ 중요한 아키텍처 결정 시
6. ✅ 외부 API 구조 변경 발견 시

### 확인 없이 진행 가능한 경우
- 간단한 버그 수정
- 변수명 변경
- 주석 추가
- 디버그 로그 추가

---

## 📈 진행도 시각화

```
Phase 1: ██████████ 100% (P1~P5 완료) ✅
Phase 2: ░░░░░░░░░░   0% (P6~P9 대기 중)
Phase 3: ░░░░░░░░░░   0% (P10~P12 대기 중)
Phase 4: ░░░░░░░░░░   0% (P13~P15 대기 중)
Phase 5: ░░░░░░░░░░   0% (P16~P19 대기 중)
Phase 6: ░░░░░░░░░░   0% (P20~P22 대기 중)
Phase 7: ░░░░░░░░░░   0% (P23~P26 대기 중)
```

매 Phase 시작/종료 시 진행도 업데이트

---

## 🎓 학습 및 개선

### 태스크 완료 후 회고 (선택)
- 예상 시간과 실제 시간 비교
- 어려웠던 점
- 배운 점
- 다음에 개선할 점

---

## 🔐 최종 체크리스트 (매 태스크)

태스크 완료 전 반드시 확인:
- [ ] 모든 작업 완료
- [ ] 🔴 **빌드 에러 0개 (필수)**
- [ ] 🔴 **런타임 에러 0개 (필수)**
- [ ] 🔴 **모든 테스트 항목 100% 통과 (필수)**
- [ ] 🔴 **기존 기능 회귀 테스트 통과 (필수)**
- [ ] 코드 주석 작성
- [ ] 디버그 로그 확인
- [ ] ⚠️ **위 항목 모두 통과 시에만 개발자 확인 요청**
- [ ] 체크리스트 업데이트 준비

⚠️ **중요:** 테스트 실패 시 개발자 보고 금지 → 먼저 수정 후 다시 테스트

---

## 📚 참고 문서

- **PRD:** PathcraftAI_PRD_v1_0.md
- **태스크 리스트:** TaskList_Checklist.md
- **이전 완료 태스크:** P1~P5 (Phase 1 완료)
- **GitHub Repository:** https://github.com/JinHyeokPark28/Pathcraft-AI

---

## 🚀 다음 태스크

**현재 진행:** P6 - 스태시 목업 데이터 생성  
**예상 시간:** 2시간  
**의존성:** P5 (완료)  
**주요 작업:** stash_mock.json 생성, 아이템 데이터 구조 정의

---

## 💡 특별 주의사항

### poe.ninja API 관련
- poe.ninja는 공식 API가 아닐 수 있음
- 개발자 도구로 Network 탭 확인 필수
- API 구조 변경 가능성 항상 염두
- 실패 시 캐시 데이터 사용 로직 필수

### GGG OAuth 관련
- 토큰 만료 시간 체크 (일반적으로 1시간)
- Refresh Token으로 자동 갱신
- 로그인 실패 시 사용자 친화적 메시지
- 토큰은 절대 하드코딩 금지

### AI API 관련
- API 키는 사용자 입력만 허용
- 프롬프트는 최대한 간결하게
- 토큰 비용 고려 (GPT-4 비쌈)
- 타임아웃 10초 설정
- 오프라인 모드도 지원 (AI 없이 기본 분석)

---

_작성: Claude Sonnet 4.5_  
_버전: 1.0_  
_최종 업데이트: 2025-11-02_  
_참고: 알케미스트 저니 실행 규칙 포맷 기반_

**이 규칙을 준수하면 프로젝트가 체계적으로 진행됩니다!** 🚀
